<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Untitled</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="arbeidskrav_3_regresjon_files/libs/clipboard/clipboard.min.js"></script>
<script src="arbeidskrav_3_regresjon_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="arbeidskrav_3_regresjon_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="arbeidskrav_3_regresjon_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="arbeidskrav_3_regresjon_files/libs/quarto-html/popper.min.js"></script>
<script src="arbeidskrav_3_regresjon_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="arbeidskrav_3_regresjon_files/libs/quarto-html/anchor.min.js"></script>
<link href="arbeidskrav_3_regresjon_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="arbeidskrav_3_regresjon_files/libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="arbeidskrav_3_regresjon_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="arbeidskrav_3_regresjon_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="arbeidskrav_3_regresjon_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Untitled</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="beskrive-sammenhenger" class="level1">
<h1>Beskrive sammenhenger</h1>
<section id="hvordan-kan-vi-beskrive-sammenhenger-mellom-to-kontinuerlige-variabler-i-en-regresjonsmodell-og-hva-er-koblingen-mellom-en-korrelasjonskoeffisient-og-estimatet-i-en-regresjonsmodell" class="level2">
<h2 class="anchored" data-anchor-id="hvordan-kan-vi-beskrive-sammenhenger-mellom-to-kontinuerlige-variabler-i-en-regresjonsmodell-og-hva-er-koblingen-mellom-en-korrelasjonskoeffisient-og-estimatet-i-en-regresjonsmodell">Hvordan kan vi beskrive sammenhenger mellom to kontinuerlige variabler i en regresjonsmodell og hva er koblingen mellom en korrelasjonskoeffisient og estimatet i en regresjonsmodell?</h2>
<p>Når vi skal beskrive sammenhenger mellom to kontinuerlige variabler i en regresjonsmodell, viser modellen hvordan endring i én variabel henger sammen med endringer i den andre. For eksempel kan vi undersøke hvordan den uavhengige variabelen vo2maks påvirker den avhengige variabelen Wmaks</p>
<p>En enkel lineær regresjon kan uttrykkes slik:</p>
<section id="yiβ0β1xiεi" class="level3">
<h3 class="anchored" data-anchor-id="yiβ0β1xiεi">Yi=β0+β1Xi+εi</h3>
</section>
<section id="section" class="level3">
<h3 class="anchored" data-anchor-id="section">​</h3>
<p>Her representerer <span class="math inline">\(\beta_0\)</span> skjæringspunktet, <span class="math inline">\(\beta_1\)</span> stigningstallet (den gjennomsnittlige endringen i&nbsp;<em>Y</em>&nbsp;per enhet&nbsp;<em>X</em>), og <span class="math inline">\(\varepsilon_i\)</span> den tilfeldige variasjonen. Dersom&nbsp;<em>X = vo2maks</em>&nbsp;og&nbsp;<em>Y = Wmaks</em>, vil <span class="math inline">\(\beta_1\)</span> vise hvor mye wattmaks i snitt øker per ekstra ml/min i vo2maks.</p>
<p>Sammenhengen kan også beskrives ved hjelp av korrelasjonskoeffisienten (<em>r</em>), som varierer fra -1 til 1 og uttrykker styrken og retningen på sammenhengen. En positiv korrelasjon betyr at begge variablene øker sammen, mens en negativ korrelasjon betyr at når én øker, går den andre ned. I enkel lineær regresjon henger korrelasjon og regresjon sammen: jo sterkere&nbsp;<em>r</em>, desto tydeligere blir sammenhengen i modellen. Forklaringsgraden (<em>R²</em>) er lik&nbsp;<em>r²</em>, og viser hvor stor andel av variasjonen i&nbsp;<em>Y</em>&nbsp;som forklares av&nbsp;<em>X</em>.</p>
<p>Eksempelet viser at korrelasjonen mellom vo2maks og maksimal effekt er r = 0,79, som indikerer en sterk positiv sammenheng. Regresjonskoeffisienten β₁ = 0,056 betyr at for hver økning på 1 ml/min i vo2maks, øker wattmaks med gjennomsnittlig 0,056 watt (56 watt per 1000 ml/min økning). R² viser at 63% av variasjonen i wattmaks kan forklares av forskjeller i vo2maks.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = end.load ~ VO2.max, data = cycling)

Residuals:
    Min      1Q  Median      3Q     Max 
-67.786 -16.277   0.006  14.970  54.428 

Coefficients:
             Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 1.525e+02  2.440e+01   6.249 2.38e-08 ***
VO2.max     5.601e-02  5.011e-03  11.178  &lt; 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 23.1 on 74 degrees of freedom
  (4 observations deleted due to missingness)
Multiple R-squared:  0.628, Adjusted R-squared:  0.623 
F-statistic: 124.9 on 1 and 74 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Pearson's product-moment correlation

data:  cycling$VO2.max and cycling$end.load
t = 11.178, df = 74, p-value &lt; 2.2e-16
alternative hypothesis: true correlation is not equal to 0
95 percent confidence interval:
 0.6903832 0.8636365
sample estimates:
      cor 
0.7924875 </code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="arbeidskrav_3_regresjon_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="hvordan-kan-vi-beskrive-sammenhengen-mellom-en-kontinuerlig-avhengig-variabel-og-en-uavhengig-kategorisk-variable-med-en-regresjonsmodell-og-hvordan-tolker-vi-estimatet" class="level2">
<h2 class="anchored" data-anchor-id="hvordan-kan-vi-beskrive-sammenhengen-mellom-en-kontinuerlig-avhengig-variabel-og-en-uavhengig-kategorisk-variable-med-en-regresjonsmodell-og-hvordan-tolker-vi-estimatet">Hvordan kan vi beskrive sammenhengen mellom en kontinuerlig avhengig variabel og en uavhengig kategorisk variable med en regresjonsmodell og hvordan tolker vi estimatet</h2>
<p>Når den avhengige variabelen er kontinuerlig, men den uavhengige er kategorisk, kan vi fortsatt bruke en lineær regresjonsmodell for å undersøke forskjeller mellom grupper. Vi kan undersøke om menn og kvinner har forskjellig gjennomsnittlig løpshastighet i Boston Marathon. Modellen kan skrives som:</p>
<p><span class="math display">\[Yi=β0+β1(genderM)i+εi\]</span></p>
<p>​Her representerer <span class="math inline">\(\beta_0\)</span> gjennomsnittet for referansegruppen (kvinner, kodet som 0), mens <span class="math inline">\(\beta_1\)</span> viser forskjellen i gjennomsnittlig hastighet mellom menn og kvinner. Dersom <span class="math inline">\(\beta_1\)</span> er positiv, betyr det at menn i gjennomsnitt har høyere hastighet enn kvinner med en verdi tilsvarende størrelsen på <span class="math inline">\(\beta_1\)</span>. Resultatene fra regresjonsmodellen viste at gjennomsnittshastigheten for kvinner var β₀ = 9,58 km/t, mens menn i gjennomsnitt løp β₁ = 0,86 km/t raskere.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = speed ~ gender, data = boston_dat)

Residuals:
    Min      1Q  Median      3Q     Max 
-5.1395 -1.2005  0.0377  1.1376  8.5530 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  9.57976    0.01876  510.67   &lt;2e-16 ***
genderM      0.86218    0.02455   35.12   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.776 on 21551 degrees of freedom
Multiple R-squared:  0.05414,   Adjusted R-squared:  0.0541 
F-statistic:  1234 on 1 and 21551 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="arbeidskrav_3_regresjon_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="hvordan-kan-vi-tolke-estimatet-i-en-generalisert-lineær-modell-hvor-den-avhengige-variabelen-er-enten-1-eller-0-hva-betyr-link-function-i-denne-sammenhengen-og-hva-gjør-den" class="level2">
<h2 class="anchored" data-anchor-id="hvordan-kan-vi-tolke-estimatet-i-en-generalisert-lineær-modell-hvor-den-avhengige-variabelen-er-enten-1-eller-0-hva-betyr-link-function-i-denne-sammenhengen-og-hva-gjør-den">Hvordan kan vi tolke estimatet i en generalisert lineær modell hvor den avhengige variabelen er enten 1 eller 0? Hva betyr «link-function» i denne sammenhengen og hva gjør den?</h2>
<p>Når den avhengige variabelen bare kan være 1 eller 0 (for eksempel skade = 1 og ingen skade = 0), bruker vi en logistisk regresjon. Det er en type generalisert lineær modell som gjør det mulig å analysere sannsynligheter.</p>
<p>Siden sannsynligheter alltid må ligge mellom 0 og 1, brukes en link-funksjon kalt logit, som gjør om sannsynligheten (p) til log-odds. Dette lar oss bruke en lineær modell til å beskrive sammenhengen mellom variablene:</p>
<p>logit(p)=log⁡(p1−p)=β0+β1Xi​</p>
<p>Her viser&nbsp;β1​&nbsp;hvordan log-oddsen for skade endres når den uavhengige variabelen endres med én enhet. Når vi tar den naturlige eksponenten av estimatet (eβ1​), får vi odds-ratio, som forteller hvor mye oddsen for skade øker eller minker.</p>
<p>I eksempelet under undersøkes sammenhengen mellomvoppvarmingsrutine og hamtringsfleksibilitet og risiko for skade. Modellen predikerer log-odds for skade, som deretter omregnes til odds ved hjelp av exp()-funksjonen. Når hamstringsfleksibiliteten er 80, viser resultatene at oddsen for skade er 1,70 uten oppvaring og 0,55 med oppvarming. Dette betyr at spillere som følger oppvarmingsrutinen har lavere odds for skade sammenlignet med dem som ikke gjør det.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 × 3
  Warmup_Routine_Adherence Hamstring_Flexibility  odds
                     &lt;dbl&gt;                 &lt;dbl&gt; &lt;dbl&gt;
1                        0                    80 1.70 
2                        1                    80 0.554</code></pre>
</div>
</div>
<section id="predikere-mulige-observasjoner" class="level3">
<h3 class="anchored" data-anchor-id="predikere-mulige-observasjoner"><em>Predikere mulige observasjoner</em></h3>
<p>- Bruk data fra datasettet strengthvolume og lag en prediksjonsmodell for legext basert på legpress.<br>
- Bruk data fra en tidspunkt (time) og et treningsvolum (sets)</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(exscidata)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"strengthvolume"</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">#liten titt på datasett</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="fu">glimpse</span>(strengthvolume)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 3,276
Columns: 8
$ participant &lt;chr&gt; "FP13", "FP13", "FP13", "FP13", "FP13", "FP13", "FP13", "F…
$ sex         &lt;chr&gt; "male", "male", "male", "male", "male", "male", "male", "m…
$ include     &lt;chr&gt; "incl", "incl", "incl", "incl", "incl", "incl", "incl", "i…
$ time        &lt;chr&gt; "pre", "pre", "pre", "pre", "session1", "session1", "sessi…
$ sets        &lt;chr&gt; "single", "multiple", "single", "multiple", "single", "mul…
$ leg         &lt;chr&gt; "R", "L", "R", "L", "R", "L", "R", "L", "R", "L", "R", "L"…
$ exercise    &lt;chr&gt; "legpress", "legpress", "legext", "legext", "legpress", "l…
$ load        &lt;dbl&gt; 115.0, 115.0, 55.0, 55.0, 125.0, 125.0, 55.0, 55.0, 185.0,…</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#filtrere og omstrukturere data, (et tidspunkt + et treningsvolum)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> exscidata<span class="sc">::</span>strengthvolume <span class="sc">%&gt;%</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(time <span class="sc">==</span> <span class="st">"post"</span>, sets <span class="sc">==</span> <span class="st">"multiple"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(participant, sex, exercise, load) <span class="sc">%&gt;%</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_wider</span>(<span class="at">names_from =</span> exercise, <span class="at">values_from =</span> load, <span class="at">values_fn =</span> mean)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#lage modellene</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>m1 <span class="ot">&lt;-</span> <span class="fu">lm</span>(legext <span class="sc">~</span> legpress, <span class="at">data =</span> dat)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>m2 <span class="ot">&lt;-</span> <span class="fu">lm</span>(legext <span class="sc">~</span> sex <span class="sc">+</span> legpress, <span class="at">data =</span> dat)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(m1)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = legext ~ legpress, data = dat)

Residuals:
    Min      1Q  Median      3Q     Max 
-33.270 -17.122  -3.403  16.324  34.831 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 20.15202   15.04075   1.340     0.19    
legpress     0.27032    0.05693   4.748 4.42e-05 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 19.64 on 31 degrees of freedom
  (6 observations deleted due to missingness)
Multiple R-squared:  0.421, Adjusted R-squared:  0.4024 
F-statistic: 22.54 on 1 and 31 DF,  p-value: 4.416e-05</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(m2)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = legext ~ sex + legpress, data = dat)

Residuals:
    Min      1Q  Median      3Q     Max 
-26.300  -7.317  -0.837   9.239  32.127 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 33.63303   11.70910   2.872  0.00741 ** 
sexmale     28.44486    5.79124   4.912 2.99e-05 ***
legpress     0.16431    0.04819   3.410  0.00188 ** 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 14.87 on 30 degrees of freedom
  (6 observations deleted due to missingness)
Multiple R-squared:  0.6791,    Adjusted R-squared:  0.6577 
F-statistic: 31.74 on 2 and 30 DF,  p-value: 3.941e-08</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#predict legext uavhengig av kjønn ved 200kg legpress</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(m1, <span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">legpress =</span> <span class="dv">200</span>), <span class="at">interval =</span> <span class="st">"prediction"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>       fit      lwr      upr
1 74.21523 33.01092 115.4195</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">#predict legext på menn og kvinner ved 200kg legpress</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(m2, <span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">legpress =</span> <span class="dv">200</span>, <span class="at">sex =</span> <span class="st">"male"</span>), <span class="at">interval =</span> <span class="st">"prediction"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>      fit      lwr      upr
1 94.9399 62.54697 127.3328</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(m2, <span class="at">newdata =</span> <span class="fu">data.frame</span>(<span class="at">legpress =</span> <span class="dv">200</span>, <span class="at">sex =</span> <span class="st">"female"</span>), <span class="at">interval =</span> <span class="st">"prediction"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>       fit      lwr     upr
1 66.49504 35.10477 97.8853</code></pre>
</div>
</div>
</section>
<section id="hvordan-spiller-kjønn-sex-inn-på-prediksjonen-hvordan-kan-du-bruke-kjønn-for-å-si-noe-om-prediksjoner-innad-kjønn-og-i-gjennomsnitt-i-begge-kjønn" class="level3">
<h3 class="anchored" data-anchor-id="hvordan-spiller-kjønn-sex-inn-på-prediksjonen-hvordan-kan-du-bruke-kjønn-for-å-si-noe-om-prediksjoner-innad-kjønn-og-i-gjennomsnitt-i-begge-kjønn">Hvordan spiller kjønn (sex) inn på prediksjonen, hvordan kan du bruke kjønn for å si noe om prediksjoner innad kjønn og i gjennomsnitt i begge kjønn?</h3>
<p>Kjønn har en stor effekt. Modellen viser oss at menn har 28.4 kg høyere forventet legext enn kvinner, selv når begge har 200kg legpress. Dette betyr at for å gjøre en god prediksjon, må vi absolutt ta kjønn med i beregningen.</p>
<p>For prediksjoner innad i hvert kjønn bruker vi den samme stigningen på 0.164, men med forskjellig utgangspunkt. For en gjennomsnittlig prediksjon over begge kjønn får vi et mindre nøyaktig estimat som egentlig ikke passer for noen av gruppene.</p>
</section>
<section id="modellen-gir-deg-et-estimat-men-for-en-gitt-verdi-på-legpress-hva-sier-modellen-om-i-hvilket-område-vi-kan-forvente-å-finne-nye-observasjoner" class="level3">
<h3 class="anchored" data-anchor-id="modellen-gir-deg-et-estimat-men-for-en-gitt-verdi-på-legpress-hva-sier-modellen-om-i-hvilket-område-vi-kan-forvente-å-finne-nye-observasjoner">Modellen gir deg et estimat, men for en gitt verdi på legpress, hva sier modellen om i hvilket område vi kan forvente å finne nye observasjoner?</h3>
<p>For en gitt legpress verdi (200kg), gir modellen oss et prediksjonsintervall. For en ny kvinnelig utøver med 200kg i legpress, sier modellen at vi med 95% sikkerhet kan forvente at hennes faktiske legext verdi vil være mellom lwr 35.1 kg, fit på 66.4 og upr 97.9 kg. Intervallet tar høyde for den naturlige variasjonen som vil være mellom individuelle utøvere.</p>
</section>
<section id="trekke-slutninger" class="level3">
<h3 class="anchored" data-anchor-id="trekke-slutninger"><em>Trekke slutninger</em></h3>
<p>- Bruk datasettet strengtvolume og formuler en modell som gir oss et estimat på forskjell i gjennomsnitt mellom sets i forandring fra tidspunkt pre til tidspunkt post i legext. Gi begrunnelse til valg av modell og håndtering av data.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>           Parameter Estimate   SE
1        (Intercept)    89.32 3.17
2            timepre   -32.47 1.93
3         setssingle    -3.94 2.00
4 timepre:setssingle     4.39 2.72
5    sd__(Intercept)    17.68   NA
6    sd__Observation     8.19   NA</code></pre>
</div>
</div>
<section id="begrunnelse" class="level4">
<h4 class="anchored" data-anchor-id="begrunnelse">Begrunnelse</h4>
<p>Den individuelle utgangspunktvariasjonen av leg extentions er på 17,68 enheter (SD_Intercept), i tillegg er pre -og postverdiene avhengige, de er fra samme individ. Dette betyr at det ikke er gunstig å anvende en tradisjonell lineær modell, siden den antar at pre -og postverdiene var uavhengige. Modellen hadde heller ikke tatt rede for variasjon i utgangspunkt. Derfor valgte vi å ta i bruk en mixed model for å finne den gjennomsnittlige forskjellen av endring fra pre til post mellom ett og flere sett. En mixed model vil anta at det er variasjoner imellom individer og innad i samme individ. I tillegg vil den anta at det er sammenheng mellom pre -og posttest, siden det er de samme individene som gjennomfører begge tester.</p>
</section>
</section>
<section id="hvordan-kan-vi-bruke-regresjonsmodellen-for-å-si-noe-om-populasjonen-som-dataene-kommer-fra" class="level3">
<h3 class="anchored" data-anchor-id="hvordan-kan-vi-bruke-regresjonsmodellen-for-å-si-noe-om-populasjonen-som-dataene-kommer-fra">Hvordan kan vi bruke regresjonsmodellen for å si noe om populasjonen som dataene kommer fra?</h3>
<p>Modellen tar pre og “multiple sets” gruppen som utgangspunkt i analysen. Dette vil si at “Multiple sets” gruppen hadde 89,32 enheter belastning ved pre (intercept), som var 32,47 enheter lavere ved pre enn ved post (timepre). “Single sets” gruppen hadde et utgangspunkt 3,94 enheter lavere enn “multiple sets” gruppen(setssingle). “Multiple sets” gruppen økte med 4,39 enheter mer enn “Single sets” gruppen(timepre:setssingle). Derfor kan modellen indikere at flere sett leder til større økning av styrke i populasjonen.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>